<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{ SERVER_NAME }}</title>
  <link rel="icon" type="image/webp" href="{{ url_for('static', filename='favicon.webp', v=favicon_timestamp) }}" />
  <link rel="stylesheet" href="/static/modern-style.css" />
  <script>
    // Set accent color from environment variable
    document.addEventListener('DOMContentLoaded', function() {
      const accentColor = '{{ ACCENT_COLOR or "#d33fbc" }}';
      document.documentElement.style.setProperty('--accent-color', accentColor);
      
      // Enhanced collapsible section animations - simplified to prevent margin issues
      const collapsibleSections = document.querySelectorAll('details.collapsible-section');
      
      collapsibleSections.forEach(details => {
        const summary = details.querySelector('summary');
        
        if (!summary) return;
        
        // Let CSS handle the animations naturally
        summary.addEventListener('click', function(e) {
          // Allow default behavior but add smooth transitions
          const isOpen = details.hasAttribute('open');
          
          if (!isOpen) {
            // Add a small delay to ensure smooth opening
            setTimeout(() => {
              details.style.transition = 'all 0.3s ease';
            }, 10);
          }
        });
      });
    });
  </script>
</head>
<body>
  {% include "_bottom_nav.html" %}
  
  <!-- Fixed bottom-left service icons -->
  {% if services and QUICK_ACCESS_ENABLED == 'yes' %}
    <div class="quick-access-panel">
      <div class="quick-access-title">Quick Access</div>
      <div class="quick-access-grid">
        {% for service in services %}
          <div class="quick-access-item">
            <a href="{{ service.url }}" target="_blank" title="{{ service.name }}" class="service-link">
              <img src="{{ url_for('static', filename=service.logo) }}" alt="{{ service.name }} logo" class="quick-access-icon">
            </a>
            <div class="quick-access-label">
              {% if service.name == "Plex" %}
                Media
              {% elif service.name == "Audiobookshelf" %}
                Books
              {% elif service.name == "Tautulli" %}
                Stats
              {% elif service.name == "Overseerr" %}
                Request
              {% else %}
                {{ service.name }}
              {% endif %}
            </div>
          </div>
        {% endfor %}
      </div>
    </div>
  {% endif %}

  <div class="onboarding-content">
    <div class="onboarding-section">
      <h1 class="onboarding-title" style="color: white !important; -webkit-text-fill-color: white !important; background: none !important;">Welcome to Audiobookshelf!</h1>
      <p class="onboarding-intro">
        While Plex can handle audiobooks, <a href="https://www.audiobookshelf.org/showcase/" target="_blank" class="accent">Audiobookshelf</a> (or just ABS) does a much better job (still for free). I reccomend it if you're an avid audio reader! You can listen on your phone or computer like Audible or Spotify.
      </p>

      <!-- Single Carousel with Library Selector -->
      <div class="carousel-section">
        <div class="poster-carousel-container">
          <div class="poster-carousel animate" id="audiobook-carousel"></div>
        </div>
      </div>

      <p class="carousel-note">
        Random selection of some audiobooks on my server. Go <a href="/medialists" class="accent">here</a> for the full list. <span class="mobile-only">On mobile, scroll horizontally to browse through covers.</span>
      </p>

      <div class="screenshot-section">
        <img src="{{ url_for('static', filename='abshome.webp') }}" alt="Homepage Example" class="toggle-grow" />
        <p class="screenshot-caption">Click to enlarge (Zoom on mobile)</p>
      </div>
    </div>

    <details {% if submitted %}open{% endif %} class="collapsible-section">
      <summary class="collapsible-heading">1. Get Access</summary>
      <p>To get started, fill out the form below. Let me know when you're done so I can add your account.</p>

      <p class="muted">
        Note: Please don't share the account you create with others. If you know someone who you think would enjoy having access, let me know. In most cases I'll be happy to add them with their own account.
      </p>
      <form method="POST" action="/audiobookshelf" id="audiobookshelf-form">
        <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
        <div class="form-group">
          <label for="email" class="form-label">Email:</label>
          <input type="email" id="email" name="email" placeholder="Enter email" required
                 class="form-input"
                 {% if submitted %}disabled{% endif %}>
        </div>
    
        <div class="form-group">
          <label for="username" class="form-label">Username:</label>
          <input type="text" id="username" name="username" placeholder="Choose a username" required
                 class="form-input"
                 {% if submitted %}disabled{% endif %}>
        </div>
    
        <div class="form-group">
          <label for="password" class="form-label">Password:</label>
          <input type="text" id="password" name="password" placeholder="Choose a password" required
                 class="form-input"
                 {% if submitted %}disabled{% endif %}>
        </div>
    
        <div class="submit-section">
          <button type="submit" class="submit-btn" {% if submitted %}disabled{% endif %}>Submit</button>
        </div>
      </form>
      <div id="audiobookshelf-success" style="display:none;">
        <div class="info-box">
          <span>âœ…</span>
          <span><strong>Thanks! Your request has been submitted.</strong></span>
        </div>
      </div>
    </details>

    <details class="collapsible-section">
      <summary class="collapsible-heading">2. Logging In</summary>
      <p>
        When I say so, you can access ABS on desktop at <a href="{{ AUDIOBOOKSHELF_URL }}" target="_blank" class="accent">{{ AUDIOBOOKSHELF_URL }}</a>, or download the app (see below) on your phone or tablet, and enter that same URL into the app when you open it.
      </p>

      <ul class="text-left max-800" style="margin: 1em 0;">
        <li><a href="https://www.audiobookshelf.org/showcase/" target="_blank" class="accent">Android</a></li>
      </ul>

      <p>
        There's no offical iOS app yet, but you can try these:
      </p>

      <ul class="text-left max-800" style="margin: 1em 0;">
        <li><a href="https://apps.apple.com/us/app/shelfplayer/id6475221163" target="_blank" class="accent">ShelfPlayer</a></li>
        <li><a href="https://apps.apple.com/us/app/plappa/id6475201956" target="_blank" class="accent">plappa</a></li>
      </ul>
    </details>

    <details class="collapsible-section">
      <summary class="collapsible-heading">3. First Time Setup</summary>
      <p>
        There's not a whole lot to do for ABS, you can start listening right away!
      </p>
    
      <p>
        Look through the settings in whichever app you get and change anything to your liking. It has useful features like an automatic sleep timer, playback speed change, bookmarking, and more. 	
      </p>

      <p class="accent">
        Note: You can download audiobooks for offline listening, in case my server is offline or you go off-grid.
      </p>

      <div class="screenshot-section">
        <img src="{{ url_for('static', filename='abssetup.webp') }}" alt="Settings" class="toggle-grow" />
        <p class="screenshot-caption">Settings Example</p>
      </div>
    </details>

    <details class="collapsible-section">
      <summary class="collapsible-heading">4. Requests</summary>
      <p>
        I don't have an automated system for requesting audiobooks (yet), but I can add them manually if available.
      </p>

      <p>
        If you want a book, look for it before you ask me. See <a href="https://fmhy.pages.dev/readingpiracyguide#audiobooks" target="_blank" class="accent">this</a> list of sites.
      </p>

      {% if tautulli_enabled %}
      <h3>Notifications</h3>
      <p>
        For notifications about newly added audiobooks, ask me about my Discord.
      </p>
      {% endif %}
    </details>

    <details class="collapsible-section">
      <summary class="collapsible-heading">5. Issues</summary>
      <p>
        If you have issues playing a specific book, let me know.
      </p>
    </details>
  </div>

  <script>
    // --- Seamless Infinite Carousel Logic (transform-based) ---
    function setupInfiniteCarousel(carousel) {
      const container = carousel.parentElement;
      let scrollSpeed = 0.5; // px per frame
      let rafId;
      let isPaused = false;
      let offset = 0;

      // Detect mobile/touch device
      const isMobile = window.matchMedia('(pointer: coarse)').matches || 
                      'ontouchstart' in window || 
                      navigator.maxTouchPoints > 0;
      
      console.log('Audiobookshelf carousel setup - Mobile detected:', isMobile);

      // If mobile, enable both auto-animation AND manual scrolling
      if (isMobile) {
        console.log('Setting up mobile audiobookshelf carousel (auto-animation + manual scrolling)');
        container.classList.add('scrollable');
        
                  // Add touch event handling with improved physics
          let isScrolling = false;
          let startX = 0;
          let scrollLeft = 0;
          let startTime = 0;
          let isUserInteracting = false; // Track if user is actively scrolling
          let lastTouchX = 0;
          let lastTouchTime = 0;
          let velocity = 0;
          let momentumInterval = null;
          
          container.addEventListener('touchstart', function(e) {
            isScrolling = true;
            isUserInteracting = true;
            startX = e.touches[0].pageX - container.offsetLeft;
            scrollLeft = container.scrollLeft;
            startTime = Date.now();
            lastTouchX = startX;
            lastTouchTime = startTime;
            velocity = 0;
            container.classList.add('scrolling');
            
            // Clear any existing momentum
            if (momentumInterval) {
              clearInterval(momentumInterval);
              momentumInterval = null;
            }
            
            console.log('Touch started - auto-scroll paused');
          }, { passive: true });
          
          container.addEventListener('touchmove', function(e) {
            if (!isScrolling) return;
            e.preventDefault();
            
            const currentX = e.touches[0].pageX - container.offsetLeft;
            const currentTime = Date.now();
            
            // Calculate velocity for momentum
            if (lastTouchTime > 0) {
              const timeDiff = currentTime - lastTouchTime;
              const distanceDiff = currentX - lastTouchX;
              if (timeDiff > 0) {
                velocity = distanceDiff / timeDiff;
              }
            }
            
            const walk = (currentX - startX) * 1.5; // Reduced multiplier for smoother feel
            container.scrollLeft = scrollLeft - walk;
            
            // Update offset to sync with manual scrolling for infinite loading
            offset = -container.scrollLeft;
            
            lastTouchX = currentX;
            lastTouchTime = currentTime;
          }, { passive: false });
          
          container.addEventListener('touchend', function(e) {
            const endTime = Date.now();
            const duration = endTime - startTime;
            
            // Remove scrolling class
            container.classList.remove('scrolling');
            
            // If it was a quick tap (less than 200ms), it might be a click
            if (duration < 200) {
              // Allow the click event to propagate to the poster link
              setTimeout(() => {
                isScrolling = false;
                isUserInteracting = false;
                console.log('Quick tap - auto-scroll resumed');
              }, 50);
            } else {
              isScrolling = false;
              
              // Apply momentum scrolling with improved physics
              if (Math.abs(velocity) > 0.2) {
                let currentVelocity = velocity * 15; // Much gentler scale for natural feel
                const friction = 0.88; // More friction for smoother deceleration
                let lastScrollLeft = container.scrollLeft;
                
                momentumInterval = setInterval(() => {
                  if (Math.abs(currentVelocity) < 0.3) {
                    clearInterval(momentumInterval);
                    momentumInterval = null;
                    setTimeout(() => {
                      isUserInteracting = false;
                      console.log('Momentum ended - auto-scroll resumed');
                    }, 200); // Longer delay to ensure auto-scroll resumes
                    return;
                  }
                  
                  const newScrollLeft = container.scrollLeft - currentVelocity;
                  container.scrollLeft = newScrollLeft;
                  
                  // Update offset to sync with momentum scrolling
                  offset = -newScrollLeft;
                  
                  // Check if we've reached the end and need more content
                  if (newScrollLeft >= container.scrollWidth - container.clientWidth - 200) {
                    // Near the end, trigger infinite loading by duplicating images
                    console.log('Near end of audiobookshelf carousel, duplicating images...');
                    duplicateImages();
                  }
                  
                  currentVelocity *= friction;
                }, 16); // ~60fps
              } else {
                // No significant momentum, just reset interaction flag
                setTimeout(() => {
                  isUserInteracting = false;
                  console.log('No momentum - auto-scroll resumed');
                }, 300);
              }
            }
          }, { passive: true });
          
          // Add scroll event listener for infinite loading during manual scrolling
          container.addEventListener('scroll', function() {
            // Update offset to sync with manual scrolling
            offset = -container.scrollLeft;
            
            // Check if we're near the end and need more content
            if (container.scrollLeft >= container.scrollWidth - container.clientWidth - 300) {
              console.log('Near end of audiobookshelf carousel during manual scroll, duplicating images...');
              duplicateImages();
            }
          }, { passive: true });
          
          // Safety mechanism to ensure auto-scroll resumes if stuck
          setInterval(() => {
            if (isUserInteracting && !momentumInterval && !container.classList.contains('scrolling')) {
              console.log('Safety reset - auto-scroll was stuck, resuming...');
              isUserInteracting = false;
            }
          }, 2000); // Check every 2 seconds
        
        // Don't return - continue to auto-animation logic below
      }

      // Duplicate initial images to allow seamless looping
      function duplicateImages() {
        const imgs = Array.from(carousel.children);
        imgs.forEach(img => {
          const clone = img.cloneNode(true);
          carousel.appendChild(clone);
        });
      }

      // Set carousel width
      function updateWidth() {
        // Instead of setting to total width, set to container's width plus a buffer
        const containerWidth = container.offsetWidth;
        // Buffer: add width of 2 images (if available)
        let buffer = 0;
        if (carousel.children.length > 0) {
          const imgWidth = carousel.children[0].offsetWidth + parseInt(getComputedStyle(carousel).gap || 0);
          buffer = imgWidth * 4;
        }
        carousel.style.width = (containerWidth + buffer) + 'px';
      }

      // Animation loop using transform
      function animate() {
                    // On mobile, pause auto-animation when user is interacting
            const shouldPauseForMobile = isMobile && isUserInteracting;
            
            if (!isPaused && !shouldPauseForMobile) {
          offset -= scrollSpeed;
          carousel.style.transform = `translateX(${offset}px)`;
          const firstImg = carousel.children[0];
          const firstImgWidth = firstImg.offsetWidth + parseInt(getComputedStyle(carousel).gap || 0);
          if (Math.abs(offset) >= firstImgWidth) {
            carousel.appendChild(firstImg);
            offset += firstImgWidth;
            carousel.style.transform = `translateX(${offset}px)`;
          }
        }
        rafId = requestAnimationFrame(animate);
      }

      // Pause on hover
      container.addEventListener('mouseenter', () => { isPaused = true; });
      container.addEventListener('mouseleave', () => { isPaused = false; });

      // Wait for images to load before starting
      const imgs = carousel.querySelectorAll('img');
      let loaded = 0;
      if (imgs.length === 0) {
        animate();
        return;
      }
      let started = false;
      function maybeStart() {
        if (!started && loaded > 0) {
          started = true;
          duplicateImages();
          updateWidth();
          animate();
        }
      }
      imgs.forEach(img => {
        if (img.complete) {
          loaded++;
          maybeStart();
        } else {
          img.addEventListener('load', () => {
            loaded++;
            maybeStart();
          });
        }
      });
      // Fallback: if all images are loaded, ensure animation starts
      if (loaded === imgs.length) {
        maybeStart();
      }
    }

    // Fetch covers with Goodreads links and initialize carousel
    fetch('/audiobook-covers-with-links')
      .then(res => res.json())
      .then(data => {
        const container = document.getElementById('audiobook-carousel');
        const posters = data.posters || [];
        const goodreadsLinks = data.goodreads_links || [];
        
        container.innerHTML = posters.map((path, index) => {
          const goodreadsLink = goodreadsLinks[index];
          if (goodreadsLink) {
            return `<a href="${goodreadsLink}" target="_blank" class="accent"><img src="${path}" class="carousel-img" alt="Audiobook cover" loading="lazy"></a>`;
          } else {
            return `<img src="${path}" class="carousel-img" alt="Audiobook cover" loading="lazy">`;
          }
        }).join('');
        setupInfiniteCarousel(container);
      });
  </script>

  <script>
    function handleSubmit(event) {
      // Allow form to submit normally and delay disabling
      setTimeout(() => {
        const inputs = document.querySelectorAll('input, button');
        inputs.forEach(el => el.disabled = true);
      }, 50); // enough time for submit to start

      return true; // let form proceed
    }
  </script>

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      // Only enable enlarge on screens wider than 1081px (adjust as needed)
      if (window.innerWidth >= 1081) {
        document.querySelectorAll(".toggle-grow").forEach(function (img) {
          img.addEventListener("click", function () {
            const isGrown = img.classList.toggle("grown");

            if (!isGrown) {
              img.style.left = "0px";
              img.style.top = "0px";
              img.style.position = "relative";
              img.style.zIndex = "";
            } else {
              img.style.position = "relative";
              img.style.zIndex = 10;
            }
          });
        });
      }
    });
  </script>

  <script>
    // AJAX audiobookshelf form submission
    document.addEventListener('DOMContentLoaded', function() {
      const form = document.getElementById('audiobookshelf-form');
      if (form) {
        form.addEventListener('submit', async function(e) {
          e.preventDefault();
          const formData = new FormData(form);
          const data = new URLSearchParams();
          for (const pair of formData) {
            data.append(pair[0], pair[1]);
          }
          const submitBtn = form.querySelector('button[type="submit"]');
          if (submitBtn) submitBtn.disabled = true;
          Array.from(form.elements).forEach(el => el.disabled = true);
          try {
            const response = await fetch('/audiobookshelf', {
              method: 'POST',
              headers: {
                'X-Requested-With': 'XMLHttpRequest',
              },
              body: data
            });
            if (response.ok) {
              const result = await response.json();
              if (result.success) {
                document.getElementById('audiobookshelf-success').style.display = '';
                form.style.display = 'none';
              } else {
                alert(result.error || 'Submission failed.');
                Array.from(form.elements).forEach(el => el.disabled = false);
                if (submitBtn) submitBtn.disabled = false;
              }
            } else {
              alert('Submission failed.');
              Array.from(form.elements).forEach(el => el.disabled = false);
              if (submitBtn) submitBtn.disabled = false;
            }
          } catch (err) {
            alert('Submission failed.');
            Array.from(form.elements).forEach(el => el.disabled = false);
            if (submitBtn) submitBtn.disabled = false;
          }
        });
      }
    });
  </script>

  <!-- Navigation Script -->
  <script src="{{ url_for('static', filename='navigation.js') }}"></script>

</body>
</html>
